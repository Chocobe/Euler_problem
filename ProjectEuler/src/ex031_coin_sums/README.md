# Coin sums
# (코인 합)

In England the currency is made up of pound, "Livre or pound", and pence, p, 
and there are eight coins in general circulation:

(영국 화폐는 "리브르 또는 파운드", p인 "펜스"로 이루어 져있고, 일반적인 순환으로 8코인이 있다.)

1p, 2p, 5p, 10p, 20p, 50p, "Livre 1"(100p) and "Livre 2"(200p).

(1p, 2p, 5p, 10p, 20p, 50p, 리브르 1(100p), 리브르 2(200p)이다.)

It is possible to make "Livre 2" in the following way:

(다음과 같은 방법으로 "리브르 2"를 만들 수 있다.)

1×"Livre 1" + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p

How many different ways can "Livre 2" be made using any number of coins?

(코인들의 어떠한 수든 사용하여 만들어 지는 "리브르 2"의 방법은 얼마나 되는가?)

(즉, 코인들을 사용하여 "리브르 2"를 표현가능한 방법의 갯수를 찾는것.)

# 문제점_1
이 문제는 200을 (1, 2, 5, 10, 20, 50, 100, 200)의 숫자로 표현할 수 있는 방법 수를 찾는 것이었다.

쉽게 생각 하면 거스름돈을 주는 방법의 경우의 수를 구하는 것.

규칙을 찾기 위해 10p의 값을 대상으로 생각해 보았다.

화폐는 (1, 2, 5, 10) 4가지만 사용.

(w == 10, x == 5, y == 2, z == 1) 의 화폐에 대한 개수라고 할 때,

방정식으로 표현하면 다음과 같다.
	(10p * w) + (5p * x) + (2p * y) + (1p * z)

각 항의 최대값을 하나씩 대입해볼 경우,

각 항의 값을 목표값에서 뺀 값, 즉 빼고 남은값에 대한 다음항의 연산이 재귀적으로 이루어 짐을 알 수 있다.

그러므로, "대상값"과 다음항의 "최대 사용 횟수"를 갱신하는 재귀메서드가 만들어 진다.

결과값인, 표현 방법의 경우의 수는 마지막 항에 도달했을 시, 하나씩 증가시키면 된다.

만약 다시 풀어야 될 경우, 이렇게 풀 수 있을지 의문이 든다...

이번 문제에서는 재귀 메서드에 대한 로직도 맘에 들게 풀어졌고,

수행시간에 대해서도 만족스럽다. (0.003초)

# 문제점_2
재귀 메서드를 만들 시,

디버깅이 매우 어려웠다.

디버깅을 어떤 식으로 생각해야 헷갈림 없이 할 수 있을지 고찰이 필요하다.